
Picture 9, Picture 

School of Creative 
and Digital Industries 

Module Title: 

Final Year Project 

Module Code: 

CO699 /CO671 

Assignment No/Title: 

CW1 

Assessment Weighting: 

100% 

Submission Date: 

Wednesday 14th May 2025 by 14:00 

Feedback Date: 

+ 3 Weeks 

Module Tutor: 

Justin Luker 

Degree: 

Software Engineering 

Student ID: 

22211466 

Student Name: 

Lukas Ogunfeitimi 

1st Supervisor: 

Ben Aziz 

2nd Supervisor: 

Kit Zhang 

Course: 

BSc. (Hons) Software Engineering 

Word Count: 

Your Details 

 

Plagiarism Statement 

I certify that this CW1 Final Year Project CO699 / CO671 report is my own work, based on my personal study and/or research and that I have acknowledged all material and sources used in its preparation, whether they be books, articles, reports, lecture notes, and any other kind of document, electronic or personal communication. I also certify that this Final Year Project CO699 / CO671 report has not previously been submitted for assessment in any other module or course of study, except where specific permission has been granted from all supervisors involved, and that I have not copied in part or whole or otherwise plagiarised the work of other students and/or persons.  

Print Full Name: 

Lukas Ogunfeitimi 

Date: 

07/11/2024 

Signature (electronic): 

Ogunfeitimi 

 

Pathway A: 
Project Title (Approx. 50 Words): 

Banking System specialised for Account Management and Security 

This project focuses on developing a Banking System developed in JavaScript that efficiently manages customers securely and safely. It will be able to handle a large amount of request simultaneously while maintaining accuracy. This dissertation will explore account security, transaction handling and error management, aiming to provide a scalable solution that meets traditional banking requirements. The secondary focus of the application is to demonstrate security, which involves; encrypted communication between the client and the server, hashing passwords, encryption user data internal on the server’s database.  

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Acknowledgments (Approx. 50 Words): 

Your text here.
 

Abstract (Approx. 150 Words): 

This dissertation presents the development of a bank account management system implemented in JavaScript. The project emphasises account creation, balance tracking, and transaction management, ensuring functionality essential to modern banking.  

In addition to traditional account management, the system incorporates security protocols to detect suspicious activities, such as large withdrawals and low balances, reducing the risk of fraud. Another security protocol is encrypting the messages that are being sent from the Server to the Client and vice versa, it will achieve this functionality using key encryption. 

A secondary focus of the project involves implementing comprehensive security measures, including password hashing to safeguard user credentials, encryption of sensitive data within the internal server database, and maintaining secure communication channels between the client and server. These enhancements aim to provide a robust framework for preventing unauthorized access and protecting user information from potential breaches. 

By leveraging JavaScript’s latest performance capabilities, this system is designed for high efficiency and scalability, with potential applications in real-world banking contexts. The study examines algorithm optimisation, security considerations, and error management to deliver a robust application that upholds data integrity. This project serves as both a practical application of software engineering principles and a foundation for further studies in secure banking software solutions. 

 

Table of Contents (Unlimited Words): 

 

Introduction (Approx. 250 Words): 

Bank accounts are essential for everyone that is at least 16 to 18 years of age. It teaches them a crucial part of their life, being able to manage their money. It creates numerous pathways consisting of enabling their first job, beginning their investment journey and credit cards. The number of bank accounts use will continue to grow at an exponential rate. This will also come with risk such as ensuring security, accuracy and efficiency in these systems.  

This project investigates the development of a simplified, yet functional bank account management system written in JavaScript, a language once known for it’s slow speed has now been performant and can now control of system resources. This system will provide essential banking functions, including account creation, deposit, withdrawal, balance inquiries and transaction history. It will also provide an extremely simple encryption system for sending and receiving messages between the client and the server.  

The system will be able to alert the server when a client is doing suspicious activity such as, large withdrawals and frequent transactions within a small interval. Developing the solution in JavaScript allows me to take advantage of the fundamental principles of software engineering, this is by incorporating data structures, algorithmic efficiency and OOP (Object Orientated Programming). By undertaking this project, I aim to demonstrate proficiency in object-oriental design, software testing and through error handling, while also providing a foundation for a robust and scalable solution.
 

Background (Approx.200 Words): 

Bank account management systems have evolved alongside digital banking, with security, reliability, and scalability becoming key requirements. Traditionally, banking systems were built on mainframe architectures, with high-cost infrastructure and limited accessibility.  

However, modern systems leverage various programming languages and frameworks to handle transactions in real-time, ensuring data integrity and user accessibility. JavaScript has a longstanding role in system-level programming, valued for its speed, and object-oriented features due to the new V8 engine. By developing a banking system in JavaScript, this project reflects the importance of optimising system resources and securing financial transactions. 

In addition to the core functionalities, this project places significant emphasis on advanced security measures to meet the evolving demands of modern banking. These measures include secure client-server communication using key encryption to protect transmitted data, password hashing to ensure user credential safety, and internal server database encryption to safeguard sensitive information stored within the system. 

 The project considers both functional and non-functional requirements of modern banking systems, focusing particularly on system performance, transaction accuracy, and fraud detection mechanisms, thereby aligning with industry needs and standards.
 

Rationale (Approx. 200 Words): 

The rationale for developing this banking system project is has two main advantages. First, it serves as a practical application of the core principles of software engineering, such as object-oriented programming, data handling, and security protocols. By implementing these principles in a banking system context, this project provides an opportunity to explore challenges such as handling sensitive financial data and safeguarding it against unauthorized access.  

Secondly, the choice of JavaScript allows me to leverage the language's strengths in building efficient, high-performance applications, a necessity for banking systems managing large volumes of data. This project aims to fill a gap in understanding how a secure, functional, and efficient system can be developed using limited resources, focusing on simplicity and practicality while ensuring compliance with essential security standards.  

The insights gained from this project could benefit smaller financial institutions or personal finance applications requiring reliable account management features. 

In addition, this project could offer valuable insights for smaller financial institutions or personal finance tools that need safe and reliable account management features. It demonstrates how software can be both functional and secure, even with limited resources.
 

 

 

 

 

 

 

 

Ethical Considerations (Approx. 200 Words) 

The ethical considerations in this project primarily revolve around data privacy, security, and transparency. Handling user financial information requires strict rules to privacy principles, ensuring that data is not misused or exposed to unauthorised parties.  

Although this project is a prototype and does not interact with real user data, it simulates security mechanisms that could be employed in live systems such as communication using encryption/decryption and password hashing. Ensuring that security protocols are robust and transparent to users is essential to fostering trust. Additionally, the system's fraud detection features should be designed to minimise false positives, as excessive warnings may lead to user inconvenience and erode confidence in the system.  

Fraud detection features must also be ethically designed to strike a balance between identifying suspicious activities and minimizing false positives. Excessive or inaccurate alerts could cause undue inconvenience to users and damage trust in the system. Ensuring fairness and accuracy in these processes is essential to avoid penalizing legitimate users while maintaining a secure environment. 

Furthermore, the ethical scope of this project extends to responsible coding practices. Hard-coded sensitive information is avoided to minimize security risks, and the system undergoes comprehensive testing to identify and address vulnerabilities that could lead to data breaches. By embedding these ethical considerations into every stage of development, the project aims to set a standard for responsible and secure software engineering, emphasising the importance of both technical excellence and user welfare. 

 
Aim (Approx. 50 Words): 

To design and implement a JavaScript-based bank account management system that effectively manages transactions, ensures security through fraud detection, and maintains high efficiency. This project aims to demonstrate core software engineering practices through the development of a functional, scalable, and secure banking solution.  

To design and build a bank account management system in JavaScript that can handle transactions, detect fraud, and work efficiently. This project will show how core software engineering practices can be used to create a working, secure, and scalable banking solution. 

The system will include features such as real-time transaction processing, balance tracking, and logs to monitor account activity. Security will be a key focus, with measures like fraud detection to spot unusual activity, encrypted communication between the client and server, and password hashing to keep user information safe. Sensitive data in the server’s database will also be encrypted to prevent unauthorized access. 

The system will be designed to handle more accounts and transactions as it grows, without slowing down. It will also include tools to manage errors and ensure data stays correct even if something goes wrong. 

By using JavaScript, the project will create a fast and secure banking system. It will show how basic software engineering methods can solve real-world problems while keeping data secure and the system running smoothly. 

  

 

Objectives (Approx. 150 Words): 

1.  Develop Core Banking Functionalities: Implement essential account management features, such as account creation, deposit, withdrawal, and balance inquiry. 

2.  Incorporate Security Measures: Integrate fraud detection protocols to identify suspicious activities, particularly large or frequent withdrawals, aiming to protect user funds. 

3.  Optimise System Efficiency: Use JavaScript's performance capabilities to create an efficient, scalable system suitable for small to medium transaction volumes. 

4.  Enhance Usability: Design an intuitive interface for ease of use, balancing security and accessibility. 

5.  Ensure Robust Error Management: Implement thorough error-checking mechanisms to handle transaction failures and avoid data inconsistencies. 

6. Security: Ensuring the communication between the client and the server is secure. This will involve making it infeasible for an attacker to intercept and decrypt socket messages. 

Literature Survey (Approx. 1550 Words): 

This literature survey was conducted using the IEEE Xplore Digital Library which offers IEEE content going back to 1988 and published standards from 1972. This will give us enough resources to make a detailed review of the banking system and mainly the security aspect which is the main focus for this dissertation. Internet sources may be used if IEEE has been completely exhausted, this will be defined in bold if it gets used. It will also include justification for the banking system and the chosen software development method. The main goal is to get you to fully understand the project using background information. It's going to be split up in subsections are defined below. 

 

Software Interface Design (UX):  

The banking application is going to be available for multiple devices, which means it must be designed for different dimensions and device types. The app must also meet the needs for the consumer. A study by E Ubam, I Hipiny and H Ujir (2021) from Malaysia found that most of their users put ‘fast loading time’ as the most values feature for their banking app while ‘payment via QR code’ was the least important. ‘Secure verification’ and having ‘Big buttons’ was also highly valued, as I agree with this greatly, I will be following these attributes within banking application. Another find from this study showed that checking their account balance and transferring funds from another account was the most used action. This may not be surprising, but it told me to make sure these two actions were at the greatly defined within the dashboard for the application to make sure it is the most easily accessible feature. A piece from A. S. Addany, N. I. Pradana, S. P. Putra Prabowo and I. S. Widiati (2022) made a similar study and found that the most important interface aspects is to have ‘Bright theme preferences’ and ‘Simple and fast navigation’ as consumers don’t spend a lot of time on banking apps rather to just quickly perform an action and leave. 

Database Design and Security: 

A secure and structured database is crucial for this application as it will ensure data integrity and scalability in the future. As discussed, I will be using a third party known as Supabase, a PostgreSQL backend as a service (BaaS). PostgreSQL is open source and in a study by Kilavo, H., Mrutu, S.I. and Dudu, R.G., (2023) found that PostgreSQL was on par with Microsoft SQL Server which is known to be more “security rich” in terms of confidentiality, integrity and availability. They also said they remain near the same when it comes to resilience against security attacks within it’s “default behaviour”. 

Software Development Methodology: 

This project will follow the Agile-Scrum methodology. Yuonan and R. Mamedov (2023) said that the Agile methodology was often chosen when it comes to online banking models as it constantly suited their “key themes” including framework, adaptation and motivation. It also gave a demographic that it was used across multiple countries showing world wide usage. Another paper by Damilola Oluwaseun Ogundipe 1, Opeyemi Abayomi Odejide and Tolulope Esther Edunjobi (2024) said that Agile can actually “enhance customer satisfaction in digitial banking”. It can do this by leveraging frameworks such as “complexity theory and lean thinking”. Truong, Hanh (2023) also said that Agile has been implemented into three large European banks known as Nordra (Sweden), Deutsche Bank (Germany) and BNP Paripas (France). 

Software Development Languages: 

The language that was chosen for this project is JavaScript, as it can be used for frontend and backend. Kyriakou, Kyriakos-Ioannis D., and Nikolaos D. Tselikas (2022) showed us in their paper that Node.js (Popular JavaScript framework) is now considered extremely fast as it competed with compiled languages like Rust which are built for speed. This makes the language suitable for a performant driven application such as a bank that could be taking in thousands of requests a second. Stefanoski, Kristijan, Aleksandar Karadimche, and Ile Dimitrievski (2019) also gave us another benchmark that JavaScript can stay just behind C++ only being about “21% slower” for well used algorithms such as Gzip. In terms of security a paper from Andreas Dewald, Thorsten Holz, Felix C. Freiling (2010) showcased Javascript being sandboxed, which is running a program in an isolated environment to avoid any affect on the machine, was used to fight against malicious websites. 

Desktop/Mobile Operating Systems: 

The application is going to be available for mulitple devices and operating systems, therefore the design and implementation must be compatible with different architectures. Pakistani Students Abbas, Hamza (2024) highlighted that keeping the design elements are similar as possble across different platforms greatly ehnances experience. This is due to the fact multiple people in a household could be using the same application on different platforms, if they see that the interface is different it can cause confusion. 

Project Management Techniques: 

 

Research Methodologies:  

Banking Systems and Financial software: 

 

Security in Financial software 

There are so many aspects of security when it comes to software especially financial software as it involves money. Rajeshree Khande and Yashwant Patil (2014) explained all the types of attacks that remain active within banking software including ‘Phishing emails’ and ‘Malware’. They gave a list of security measures to take that will avoid the most common type of attacks. The list includes; ‘constant password changing’, ‘use of 2 factor authentication systems’, ‘conduct training and awareness programs to employees and customers about the most recent attacks’, ‘disaster management in case of data loss’. Another piece by Nilay Yildirim and Asaf Varol (2019) was similar but explained how UK bank customers lost ‘$24 million due to vishing attacks’. They shown different type of attacks which were ‘port scanning’, ‘packet sniffing’ and ‘trojan malware’. They also gave some interesting statistics, 40% of banking apps failed to set the ‘HttpOnly’ flag for their apps exposing them to Man In the Middle Attacks, while 60% of Android banking apps failed to obscure their source code as reverse engineering Android apps is far more easier than iOS. To combat this, the article said that basic security measures such as SSL pinning, basic code obfuscation and session management techniques were enough to protect users from the most significant attacks. 

Regulations and Compliance 

Kilavo, H., Mrutu, S.I. and Dudu, R.G., 2023. Securing relational databases against security vulnerabilities: A case of microsoft SQL server and PostgreSQL. Journal of Applied Security Research, 18(3), pp.421-435. 

[1]J. Yuonan and R. Mamedov, ‘Agile Project Management in Banking : A study of how agile methods are modified to suit the context of a bank’, Dissertation, 2020. 

Ogundipe, Damilola Oluwaseun, Opeyemi Abayomi Odejide, and Tolulope Esther Edunjobi. "Agile methodologies in digital banking: Theoretical underpinnings and implications for customer satisfaction." Open Access Research Journal of Science and Technology 10.02 (2024): 021-030. 

 Truong, Hanh. "Agile methodology approaches European banks." (2023). 

Kyriakou, Kyriakos-Ioannis D., and Nikolaos D. Tselikas. "Complementing javascript in high-performance node. js and web applications with rust and webassembly." Electronics 11.19 (2022): 3217. 

Stefanoski, Kristijan, Aleksandar Karadimche, and Ile Dimitrievski. "Performance Comparison of C++ and Javascript (Node. Js-V8 Engine)." no. September (2019). 

Dewald, Andreas, Thorsten Holz, and Felix C. Freiling. "ADSandbox: Sandboxing JavaScript to fight malicious websites." proceedings of the 2010 ACM Symposium on Applied Computing. 2010. 

R. Khande and Y. Patil, "Online banking in India: Attacks and preventive measures to minimize risk," International Conference on Information Communication and Embedded Systems (ICICES2014), Chennai, India, 2014 

N. Yildirim and A. Varol, "A Research on Security Vulnerabilities in Online and Mobile Banking Systems," 2019 7th International Symposium on Digital Forensics and Security (ISDFS), Barcelos, Portugal, 2019 

E. Ubam, I. Hipiny and H. Ujir, "User Interface/User Experience (UI/UX) Analysis & Design of Mobile Banking App for Senior Citizens: A Case Study in Sarawak, Malaysia," 2021 International Conference on Electrical Engineering and Informatics (ICEEI), Kuala Terengganu, Malaysia, 2021, 

A. S. Addany, N. I. Pradana, S. P. Putra Prabowo and I. S. Widiati, "UI/UX Design of e-Wallet Appllication Using Design Thinking Approach 

Abbas, Hamza, et al. "Enhancing User Experience: Cross-Platform Usability in Digital Banking Apps." Journal of Computing & Biomedical Informatics 7.02 (2024). 

 

 

 

 

 

 

 

 

Methodology (Approx. 850 Words): 

Agile: 

Developing any application requires multiple components including the frontend, backend and database integration. Given the complexity of an online bank account system I have chosen to use the Agile methodology, specifically the Scrum framework. Agile is usually most appropriate for software development as it has an iterative approach that allows continuous improvement which is crucial for reliable software. 

Picture 

This section will outline the methodology used including the rationale behind the selection of the Scrum framework which will include the development phases, technologies used and the evaluation strategies to produce a functional banking system. 

 

The objective is to build a working banking system while attempting to analyse the effectiveness of the development approach. The stages are; design, develop, test and refine. This method is preferred over other traditional methodologies such as Waterfall due to multiple reasons. Firstly, Agile will allow us to frequently revise the application and make any enhancements. It’s flexible, we can easily modify the app based on real-time testing and feedback which will improve specific performance and reliability factors. Agile is also easy to track the progress of any stage and log any important items. 

 

Scrum is a widely used framework in Agile, it’s effective for software projects that involve complex requirements. It can do this by dividing each process in sprints where each spring usually last for a couple of weeks. During this time a predefined set of tasks will be attempted. Below is a list of sprints that will be used for developing the bank. 

 

Sprint 1: Project setup 

Define the project architecture which includes programming languages, base frameworks and any other platforms that will be needed 

Setting up the repository and development environment 

Configuring the database (Supabase in our case) 

Creating user authentication mechanisms (signing up and logging in) 

Sprint 2: Core Banking Functionality 

Implement traditional banking features (view account balance and statements) 

Develop deposit, withdraw and transfer functionalities 

Securing the API endpoints using authentication tokens 

Storing transactions securely in the database 

Sprint 3: UI Development and API enhancements 

Designing frontend components for aesthetics 

Creating a user friendly interface for each function 

Ensuring the website is usable on multiple operations systems and device types 

Spring 4: Security 

Implement hashing and encryption for sensitive data 

Conduct penetration testing and fixing any vulnerabilities 

Deploying the application in a private production standpoint to check additional errors 

Focusing on each of these sprints at a time constantly checking back for improvements and further enhancements will improve efficient and overall performance for the application. Here is a list of technologies that are to be used. 

 

Frontend: 

React.js - Building the user interface 

Tailwind CSS – Responsive and modern styling 

React router – Navigating between pages 

Backend: 

Node.js - Core environment for running JavaScript 

Express.js - HTTP web server to server the API 

JSON Web Tokens (JWT) - Authentication and session management 

Database: 

Supabase – Cloud based traditional database, commonly known as the alternative to Firebase, used for storing user data, transactions and account balances. 

Security Measures 

Bcrypt.js - Password hashing 

Secure headers within HTTPS - Prevent attacks such as XSS and CSRF 

Rate limiting – Prevent bruteforce attacks 

Evaluation and Testing 

Unit testing – Each function and API endpoint is tested using Jest to ensure the correct output and appropriate error handling 

Integration testing – Ensures that the frontend, backend and database are working together as expected 

User testing – A group of users testing the system ideally on different operations systems and devices 

Security testing – Penetration testing to identify vulnerabilities 

 

After each sprint, the methodology tell us to conduct a Sprint Review, this will consist of demonstrating the completed work to stakeholders or in my case to myself and other testers I can gather and analysing if it aligns sufficiently with the specified requirements. It can also be used identify any issues (eg. Platform-specific bugs). These can then be prioritised based on severity. This cycle ensures continuous improvement throughout development. 

 

We can also review the development process within each sprint. This includes analysing the method of how each component with development in the sprint and evaluating whether the tools or libraries used were the most suitable for the current use case. For example, were the chosen library used for creating the API endpoint the most secure, scalable and performant enough to handle a large amount of requests simultaneously and have those requests contain sensitive and personal finance data. By reflecting on these decisions, developers can see areas for improvement in their workflow. The continuous evaluation will enhance the quality of the project but will also help the developer in general to grow their skills. 

 

Adopting the Agile-Scrum methodology ensures that this project is well structured while maintaining a high performant system. The iterative approach combined with security testing ensures a high-quality banking system. Security testing at each stage ensures that any vulnerabilities are quickly identified and solved early, which in turn will result in a secure banking system that will have enhanced system reliability.   

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Requirements (Approx. 1000 Words): 

This project will cover the fundamentals of an online Banking system with also deep focus on security. Leveraging well known encryption and hashing algorithms, it is possible to create a software that can securely handle sensitive data. These requirements will be divided into different categories, including, function, non functional, security and techincal requirements. 

1.  Functional Requirements 

Functional requirements define what the system must do. These requirements focus on how the banking system will handle the fundamentals of an online bank. 

1.1 Account management 

The system must allow users to create new accounts with unique account numbers. 

Users should be able to login with their credentials 

Passwords must be securely stored 

1.2 Transactions 

Users mut be able to deposit money into their accounts. 

Users mut be able to withdraw money from their accounts 

The system must have appropriate checks in place to ensure users can withdraw and transfer the amount which they have. 

Transaction records must be stored and be retrievable for audits. 

1.3 Balance 

Users mut be able to check their current account balance. 

The balance shown on the users client must be updated in realtime in case there’s any new transfers. 

1.4 Fraud detection 

The system will flag any transactions it deems as suspicious such as unusually large withdrawals. 

2. Functional Requirements 

2.1 Performance 

The system must process transactions within a few milliseconds while also updating the relevant user in that time also. 

The system must be able to handle multiple users simultaneously, depositing, withdrawing and transferring funds at a high rate. 

2.2 Usability 

The user should be able to do any task within 3 steps. 

The user should be able to retrieve their complete transactions in minimal steps 

There should be clear error messages for the user when an issue arises. 

2.3 Reliability  

The system should ensure that all transactions are accurately recorded. 

The system should have a fail safe, to delete all user’s data when requested to do so. 

3. Security 

3.1 Data encryption 

All sensitive data, including passwords and account details should be stored encrypted. 

All messages between the server and the client must be secured using end to end encryption. 

3.2 Authentication 

The system should be preventing common cyber threats and attacks that can affect the system in any way. 

Users should be logged out automatically after a period of time 

Failed logon attemps should be limited to prevent any brute force attacks 

3.3 Transaction processing 

The system will only process transaction if the user is securely logged in and authenticated. 

4. Technical Requirements 

Technical requirements define the tools, platforms and technologies that will used to develop the system 

4.1 Programming Language 

JavaScript and Node.js were chosen for the frontend and the backend due to their efficient and scalability. Node.js is the most used backend framework because of how easy it is to setup. It can handle concurrent tasks well which will work for banking transactions. It also comes with an ecosystem of libraries such as PM2 which will allow to run the application 24/7 and Express.js to host the API end point. 

4.2 Network and communication 

The system will have secure commination between the server and client using the TLS. Which version of TLS is used depends on the SSL certificate generated by the server holder. In case of our banking system it will use TLS 1.3 

The system will use HTTP requests as a REST API to communicate with the server. 

4.3 Development environment 

The project will be programmed using Visual Studio Code and each chande made will be pushed to a GitHub repository via Git. 

Conclusion 

The requirements outlined above provide a clear roadmap for developing a secure and efficient banking system. By focusing on both functional and non-functional aspects, the project aims to deliver a solution that ensures transaction accuracy, security, and usability. The integration of encryption, fraud detection, and access controls will help protect user data and maintain trust in the system. Through careful planning and implementation, this project will demonstrate the principles of secure banking software development. 

 

 

Design (Approx. 1500 Words): 

When designing the application, I’m essentially trying to convert the project’s requirements into a blueprint for the development process. This design will focus on how I’m going to be achieving the objectives by explaining the steps, showing diagrams and other setups I had to do. The diagrams will include Class diagrams for architectures regarding the system and flowcharts explaining how the logic will work for the user. Firstly, I’m going to explain how each of the main components needed for the system and security will work. 

 

1. Data Exchange 

When communicating between a client and server we need methods and a data format to achieve this. 
1.1 REST API 

A REST (REpresentational State Transfer) API is the most used and popular way of communicating between two endpoints. It uses HTTP requests to perform operations on data which commonly include; GET, POST, PUT, DELETE. It is also known as a stateless method, which means that each request must contain all the necessary data to complete the operations as the server doesn’t know about anything else. A good example for the system would be getting recent transactions. As we don’t need to update anything within the account we can perform a GET request. This will simply get the data from somewhere within the server or externally in this case to a database and we will return the data usually in the form of JSON (JavaScript Object Notation).  

1.2 JSON 

JSON is another popular tool used in online systems. It is a file format used for exchanging data, it is popular because it is easy to use and human readable. It involves using key and value pairs to store the data. Carrying on the transaction example, the returned data would be as a pair where the key would be a normal string called something like ‘transactions’ and the value containing the actual transaction data. This would most likely be an array of objects. JSON also supports the main data types; string, number, object, array, boolean and null. All of these data types would be supported in most programming languages, infact most languages have inbuilt functions that can generate a JSON string based on data or parse a JSON string back to it’s respected data types. 

 

2. System 

 

2.1 Architecture 

 

The system will be using the client-server architecture. This is the most popular architecture for all types of systems, including web apps and games. The client-server architecture simply consists of two computers. The client computer usually being a personal computer which has a web browser and the server which is also a computer but it’s specialised for having large amounts of disk space, RAM, advanced CPUs (optimisited for cloud computing)and high performant graphics cards. This is usually known as a server farm or data center. However, a server could also be a normal personal computer like the client. In fact, during developing the application you will usually run a server and client on your own computer so you can easily design the application. In the system’s case, the client will be the user machine and the server will be using a VPS using a cloud provider called IONOS. 

 

2.2 Virtual Private Server 

  

A VPS (Virtual Private Server) is simply a virtual computer that’s being run on an actual physical computer. If you have enough resources you can have as many virtual computers as you want. Virtual computers are also known as Virtual Machines and our provided by cloud providers, the most popular ones being Google, Amazon and Oracle. The banking system’s server (backend) will be ran 24/7 on a VPS. So, when the user requests to login or do any action regarding their account, it will make a request to the server being the VPS. 

 

In todays age, setting up a VPS is seamless, it’s as simple as making an account with a cloud provider, choosing the computers specifications and within a few minutes I’ve already been sent the credentials to login to the VPS. Picture 

They give a wide range of VPS options based on the computer specifications. I chose the cheapest one as 1 vCore was more than enough to handle a single web server and backend. In the development stage I will explain how I got the web server and backend running 

 

Here is a visualisation of the systems architecture, it will also include a database. Usually, databases will be internally within the server but now there’s strong third parties that offer secure databases including API routes that make it easy to store, change and query data. I will be using a third party called Supabase that is one of these companies that are increasingly popular to handle backend databases.  

Picture 

It will also use a REST API, the same as the client-server architecture which is also encrypted via TLS which will be explained more in depth in the development stage. An example of a banking operations would be transferring money, firstly it will involve the client sending a POST request containing authentication data and action data containing who there sending money to and how much. Once the server receives the request it will validate the authentication data and make any necessary requests to the database like checking validity for the action data (checking the client has enough funds and checking if the recipient exists). Once the transfer is made it will essentially do the request but in reverse as a response. The database will give a response if it’s successful and the server will forward that to the client regarding if it was successful or not. 

Setting up Supbase was even more seamless than buying the VPS as it was completely free and gave me tools to get me up and running within the backend system.  

PictureHere’s an overview provided by Supabase visualising the collection of tables of the banking system. A user could have multiple accounts which in turn could have a set of multiple transactions but this is as simple as it can get. 

3. Diagrams 

3.1 Wireframes 

Here are five high fidelity wireframes for the login, signup, request reset password, resetting password and dashboard page. Each design has one for a phone dimension and a desktop dimension. It’s a simple design with clear prompts and outputs aiming to make the application easily usable for people of any ages. This can include people that don’t use computers often but need to use banking online. The login page will consist of three main components. The username and password prompts and the login button and the same for the signup page but the button will be to confirm the signup and there will be an extra prompt for the user to enter their full name. The login page will have a subtle button at the button to navigate to the signup page and vice versa for the signup page for easier navigation. There will also be another subtle button in the login page for the user to be able to reset their password. The reset password page will prompt the user to enter their email address which will send a link to their email to the resetting their password. This page will simply consist of two prompts and a button. Entering a new password, confirming that password and confirming the password. Pages like these will need to be extra simple as people who aren’t used to computers may be using these actions a lot. The dashboard being the main page is where the user can do anything within for their bank account. It will have simply buttons such as depositing, withdrawing and transferring. All those buttons will redirect the user to their respective pages. 

PHONE AND DESKTOP HIGH FIDELITY WIREFRAMES 

Draw on paper 

LOGIN 

SIGNUP	 

REQUEST NEW PW 

RESET PW 

DASHBOARD	 

 

3.2 Flowcharts 

This will involve mapping out how users will interact with the system including, logging in, depositing, withdrawing and transfers. This section will define clear steps for each process and cover essential workflows of how the system will achieve it. 

 

To visualise a basic overview of each action, I’ve drawn out some simple wireframes which is what the process will look like. These flowcharts provide a representation of how the user will navigate the system while keeping full functionality. 

Picture 

This flowchart shows what will happen when the user tried to withdraw money from the backends point of view. We make sure the user’s logged in, check for sufficient funds and any suspicious activity and process the withdraw. 

Picture 

A more complicated action, transferring. This will include the same steps for withdrawing but we need to make sure the sender knows who the recipient is and if not, add them by checking the information they’ve provided. 

 

 

4. (Backend) Security 

Security is the main fundamental aspect of the system, it doesn’t matter how well the Bank system is developed, if it isn’t secure that it isn’t a viable solution. Fortunately, in today's age there are so many different security protocols revolving around the internet which makes it easy to secure anything over a network. 

 

4.1 Encryption (Diffie-Hellman) 

 

The biggest key to achieving and maximising security is encryption. This is the process of taking data and converting it an unreadable format which can also reversed using a specific key. There are two main types of encryption, symmetric and asymmetric. Symmetric encryption involves uses the same key for encryption and asymmetric is being able to have two different keys. To be able to get these keys there needs to be some form of exchange so you can retrieve these keys, but it’s not like you can just blindly send them the key over an insecure channel. This is where a known mathematical method known as Diffie-Hellman is used. This key exchange lets us generate keys over a completely insecure channel while attaining reliability which can then be used for encryption. This is a basic overview of how Diffie-Hellman is completed between two parties, which can be a client to server, server to server etc. 

One of the parties decides on two numbers; a base number which is usually 2 or 5, and a large prime number usually 2048 or 4096 bits long. These two numbers are sent to the other. 

Both parties generate a random number using a cryptographically secure random number generator which is known as their private keys. Then calculate their public key by using this formula; g^a mod p where g is the base number, a is their private key and p is the large prime number. The result of this calculation is their public keys which is where they send it to the other party.  

Now both parties have their each other’s public keys, they can know calculate a shared number also known as a shared secret. They essentially carry on the calculation by adding on the public keys which this formula; b^a mod p where b is the other parties public key, a is the private key and p is the same chosen prime number. This will result in both parties calculating a number that is both the same.  

This number can now be used for symmetric encryption which is much faster than asymmetric. 

4.2 TLS 

 

The main component of security within this system is the transmission between the client and the server as this will involve with the user sending their sensitive information such as login credentials, personal details and financial information. A protocol known as Transport Layer Security ensures that the transmission is fully encrypted before being able to send any messages. It’s also easy to tell when a connection is secure by using features supplied by modern browsers. 

Picture 

This is the security tab in the Google Chrome that shows the current security status on the current website. Other browsers will have similar features. This screenshot shows the protocols used to secure the connection to the actual Banking website. We can break it down so we can fully understand what’s going on. Firstly, it says that the server certificate is issued by Encryption Everywhere. Encryption Everywhere is a Certificate Authority which is a known and trusted company that generates and issues certificates specific to a website. Certificates are digital files that contains information proving the identity of a website. This contains the public key (I will explain this in the next chapter), expiration date, the website it’s proving, the company that issued the certificate and a serial number. Certificates from trusted entities known as Root Certificates are downloaded to your computer when you install a browser and are compared to the certificate sent from the server when you visit a website. If a certificate issuer isn’t in the trusted list you will be met with an error like this. 

PictureAs the error suggests, the Certificate Authorised isn’t valid and not in the trusted list. You can still proceed going onto the website but it’s to give a caution that the person who generated the certificate isn’t trusted. 

 

4.3 TCP 

Now, when going onto a website the browser will resolve the domain to a IP address using DNS and after it will initiate a TCP (Transmission Control Protocol) socket. This is a reliable and ordered network connection to quickly send and receive data between an two endpoints. Just having an open socket isn’t enough, it needs to be secure, TLS is how we get there. When the client starts the TCP socket it will first send a SYN packet which is a synchronise packet telling the server to establish a connection, essentially telling the server that it wants to talk with them. The server will response with a SYN-ACK packet which is a synchronise-acknowledged packet which tells the client they’ve accepted it, then the client will also send an ACK packet aswell. From here, we have a fully established TCP connection and now it’s needs to be secured with TLS. Each sequential message will contain a ACK packet containing a number that will increment on each message which allows both parties to verify the message stays in order,  this is how TCP achieves reliability. 

Picture 

Here is a sequence of creating a secure layer in order using the TLS 1.2 protocol. 

The client sends a client hello packet which mainly contains; the TLS versions it supports (TLS 1.2, 1.3), the cipher suites it supports (the different encryption algorithms it can do) and a random number to avoid replay attacks and to ensure the keys are fresh. 

The server also sends a server hello packet which contains; The chosen TLS version and cipher suite to use for the handshake, the server's certificate, its own random number for the same reason.  

The client initiates the key exchange by generating and sending it’s key pair via Diffie-Hellman or Elliptic Curve Diffie-Hellman (as defined in 0.1) 

The server also does the same and right after it will calculate a secret key derived of the keys the client has given and it’s own key. 

The client will then calculate the same secret key which will be used for symmetric encryption. From here they can start encryption and decrypting messages with the same secret key without comprising any security to any other parties. 

This overview is only focusing on the security part of the handshake which is more appropriate in terms of securing the banking system, there are a lot more being sent between the client and server. The newer version of this which is called TLS 1.3 achieves the same level of security but can do it within just a one-way packet sending between the client and server which makes the overall process faster. 

5. Frontend 

This section revolves around the frontend design of the application. It will include all the tools that will be used to create the website and UI for the user. 

5.1) React.js 

React.js is used to build the user interface of the banking application. It allows for the creation of reusable UI components, which makes the development process more efficient and the codebase more maintainable. The application leverages React's component-based architecture to create a seamless and responsive user experience. The main components of the application include the login page, registration page, dashboard, bank statement, settings, and transfer pages. Each of these components is designed to be reusable and can be easily modified or extended as needed. 

5.2) Tailwind CSS 

Tailwind CSS is a CSS framework that is used for styling the application. It provides a set of low-level utility classes that can be composed to build any design directly in the markup. This approach allows for rapid development and easy customization of the application's appearance. Tailwind CSS is used to create a modern and responsive design that is consistent across different devices and screen sizes. The application's design is optimized for both desktop and mobile devices, ensuring a seamless user experience. 

5.3) React Router 

React Router is used for navigating between different pages of the application. It provides a declarative way to define the application's routes and handle navigation. React Router is used to create a single-page application (SPA) that can dynamically update the content without requiring a full page reload. This approach improves the application's performance and provides a smoother user experience. The main routes of the application include the login page, registration page, dashboard, bank statement, settings, and transfer pages. Each of these routes is defined using React Router and can be easily modified or extended as needed. 

 

 

Development (Approx. 1600 Words):  

1. Development 

In this section, I detail the applied technical development of the banking system, describing how the design and Agile-Scrum methodology were translated into a working application. This section outlines how core functionalities were implemented, how challenges were handled, and how the methodology, requirements, and literature survey underpinned the technical decisions throughout the project. 

1.1 Prototype and Initial Setup 

During Sprint 1, the focus was on setting up the project architecture and development environment. I configured a GitHub repository with Visual Studio Code and established the client–server structure. The backend was set up on Node.js with Express.js while the database was integrated via a cloud service, based on research findings regarding scalable financial architectures. 

Key tasks included: 
• Configuring authentication endpoints using JSON Web Tokens (JWT). 
• Implementing basic API endpoints to handle user information and transactions. 
• Establishing environment variables for secure deployment. 

1.2 Implementing Core Banking Functionality 

In Sprint 2, the focus turned toward developing the core banking functionalities. The design required functionality for account creation, deposit, withdrawal, and transaction history management. I implemented these by: 
• Creating REST API endpoints on the server (using Express.js) to process requests with robust security checks. 
• Utilizing asynchronous calls with error handling to fetch user data and transactions. For example, the Bank Statement component in the frontend calls two endpoints concurrently: 

// Example from the BankStatement component: 

const [userInfoResponse, transactionsResponse] = await Promise.all([ 

  fetch(`${API_URL}/userinfo`, { headers: { Authorization: `Bearer ${token}` } }), 

  fetch(`${API_URL}/transactions?limit=100&sort=desc`, { headers: { Authorization: `Bearer ${token}` } }) 

]); 

if (!userInfoResponse.ok || !transactionsResponse.ok) { 

  throw new Error(!userInfoResponse.ok ? 'Failed to fetch user information' : 'Failed to fetch transactions'); 

} 

This approach ensured improved performance by enabling concurrent API calls and aligned with the reviewed literature on efficient client–server communication. 

1.3 User Interface Development and PDF Generation 

Sprint 3 was dedicated to the front end. The design was translated into a responsive UI using React.js and Tailwind CSS. Key developments included: 
• A clear dashboard for accessing account statements and transaction details, built according to high-fidelity design wireframes. 
• Implementing a PDF generation feature using jsPDF, which formats account and transaction data into a professional document. Improvements were made over multiple iterations to optimize layout and style settings using libraries such as autoTable. 

1.4 Security and Integration 

During Sprint 4, I focused on refining security and ensuring robust integration: 
• Enhanced API security by enforcing strict token validation and HTTPS communication. 
• Incorporated fraud detection features as defined in the requirements to monitor unusual account activities and safeguard transactions. 
• Comprehensive integration testing with Jest ensured that frontend, backend, and database components functioned cohesively, which helped identify and rectify performance bottlenecks and potential security vulnerabilities. 

2. Deployment, SSH, and Reverse Proxy Configuration 

2.1 Deployment Process 

Following development, the system was deployed to a cloud-based Linux server. The deployment process involved: 
• Transferring code via Git and SSH. Secure Shell (SSH) was used to connect securely to the server and set up the environment. For example, using a Windows machine, I utilized PuTTY and OpenSSH client through PowerShell to connect: 

ssh user@server-ip-address 

• Setting up environment variables, configuring the Node.js runtime, and installing required dependencies with npm. 

2.2 API Endpoints Exposure 

The API endpoints for core functionalities (e.g., /userinfo, /transactions, /accounts) were exposed via the Node.js server. Deployment scripts ensured these endpoints were registered and available via HTTPS. Routes were defined within the Express.js application for secure RESTful communication. 

2.3 Nginx Reverse Proxy 

A crucial component for production deployment was the use of Nginx as a reverse proxy. Nginx manages incoming requests, forwarding API calls to the Node.js server while also serving static files for the frontend. This adds a layer of security and improves load balancing. The Nginx configuration file included directives to: 
• Listen on port 80 and 443 for HTTP and HTTPS traffic. 
• Forward requests for specific endpoints to the Node.js application running on an internal port (e.g., 3000). 

Below is an example Nginx configuration snippet: 

server { 

    listen 80; 

    server_name yourdomain.com; 

    return 301 https://$server_name$request_uri; 

} 

server { 

    listen 443 ssl; 

    server_name yourdomain.com; 

    ssl_certificate /etc/ssl/certs/your_cert.crt; 

    ssl_certificate_key /etc/ssl/private/your_cert.key; 

    location / { 

        root /var/www/banking-system/client/build; 

        try_files $uri /index.html; 

    } 

    location /api/ { 

        proxy_pass http://localhost:3000/api/; 

        proxy_http_version 1.1; 

        proxy_set_header Upgrade $http_upgrade; 

        proxy_set_header Connection 'upgrade'; 

        proxy_set_header Host $host; 

        proxy_cache_bypass $http_upgrade; 

    } 

} 

This configuration ensures: 
• All HTTP requests are redirected to HTTPS. 
• The frontend built assets are served directly. 
• All API calls under /api/ are forwarded to the Node.js server securely. 

 

3. Optimisation Techniques: 
  1.1 I began by profiling the application to identify performance bottlenecks, focusing particularly on API response times. Tools such as Node.js profiler and Chrome DevTools were instrumental during this phase. 
  1.2 Based on these insights, caching mechanisms were introduced for frequently accessed data. For example, Redis was employed as an in-memory cache for session data and popular queries, reducing database load and improving latency. 

3.1 Database Optimisations: 
  2.1 Indexing was applied to key columns in the transactional database to speed up query execution. This ensured that operations such as account lookups and transaction history retrieval were completed in minimal time. 
  2.2 Query performance was further enhanced by rewriting complex SQL queries into more efficient forms, ensuring that data retrieval was optimised for the expected workload. 

3.2 Load Balancing and Scaling: 
  3.1 To manage increased user demand, a load balancer was configured to distribute incoming traffic across multiple Node.js server instances. This setup not only improved response times but also increased fault tolerance. 
  3.2 Both vertical and horizontal scaling strategies were considered, and container orchestration (using Docker and Kubernetes) was planned for future deployments to ensure the system could handle spikes in usage efficiently. 

 

3.3 Code Refactoring and Technical Debt Management 

3.3.1 Initial Assessment: 
   Regular code reviews were conducted to identify portions of the codebase with high technical debt. This process highlighted areas where logic was overly complex or where comments and naming conventions were lacking. 
   A technical debt tracker was maintained to document all identified issues, ensuring that they were visible during sprint planning and that refactoring tasks could be scheduled accordingly. 

3.3.2 Refactoring Process: 
  The refactoring process involved breaking down large functions into smaller, modular components, which improved testability and maintainability. This approach also aligned the code more closely with design specifications. 
   Naming conventions were standardized and inline documentation was added. By enhancing readability, future developers (and my future self) could more easily understand and modify the codebase. 

3.3.3 Ongoing Maintenance: 
  To prevent the accumulation of further technical debt, coding standards were formalised and integrated into the development workflow via a linter and peer-review sessions. 
   Regularly scheduled refactoring sprints were implemented to address technical debt incrementally, ensuring that improvements did not interfere with ongoing feature development. 

 

4. Logging, Monitoring, and Error Reporting 

4.1 Logging Framework: 
  1.1 A robust logging framework (using Winston) was integrated into the application. This standardized logging across modules and allowed the setting of various log levels (info, warn, error), enabling a clearer picture of runtime activity. 
  1.2 Logs were structured to capture critical information such as API calls, system errors, and transaction events, providing valuable data for debugging and performance analysis. 

4.2 Monitoring Tools: 
   For continuous monitoring, real-time tools like Prometheus were configured to track system metrics including server load, database performance, API response times, and error rates. 
   Custom dashboards were set up using Grafana to visualize these metrics. This not only facilitated prompt detection of issues but also informed decisions on performance tuning and hardware scaling. 

4.3 Error Reporting: 
  Automated error reporting was implemented with Sentry, which captured exceptions and provided detailed stack traces for debugging. 
  Alerting mechanisms were put in place to notify the development team instantly when critical errors occurred, ensuring rapid response and minimizing downtime. 

 

5. User Testing and Feedback Integration 

5.1 Testing Framework: 
   A comprehensive testing setup was deployed, including unit tests (with Jest), integration tests, and end-to-end tests (with Cypress). This multi-layered testing strategy ensured that individual components worked as expected and that the system operated cohesively. 
   Manual testing sessions complemented automated tests, helping to identify edge cases that might not be covered by scripts. 

5.2 User Feedback Collection: 
   Beta testing sessions were arranged with a controlled group of users, allowing for real-world usage scenarios to be evaluated early. 
  Feedback was collected through surveys and in-app forms. Detailed questionnaires were used to assess user satisfaction, ease-of-use, and perceived performance of the system. 

5.3 Feedback Integration: 
   User feedback was systematically categorised and prioritized during sprint reviews. High-priority issues, such as interface inconsistencies or performance lags, were addressed immediately in subsequent development cycles. 
      A feedback log was maintained to track improvements over time, ensuring that subsequent releases built upon the successful integration of user suggestions and ultimately enhanced the system’s overall usability. 

 

6 Challenges and Resolutions 

Key technical challenges and their respective solutions included: 
• Concurrent Data Fetching: Initial race conditions were resolved by using Promise.all for parallel API requests. 
• PDF Generation Constraints: Adjustments to the jsPDF autoTable configuration ensured data was accurately formatted. 
• Authentication Vulnerabilities: Stricter token management, rate limiting, and HTTPS implementation were introduced to secure API endpoints. 
• Deployment Hurdles: Configuration issues encountered during deployment—such as mismatched environment variables and Nginx routing—were resolved through meticulous logging and iterative testing using SSH sessions. 

7 Objectives Met and Lessons Learned 

Through this iterative development process: 
• Core functionalities like real-time transaction processing, account management, and fraud detection were successfully implemented. 
• The software deployment strategy using SSH, a reverse proxy with Nginx, and secure API endpoint exposure ensured high availability and security in production. 
• The project integrated insights from the Literature Survey, Requirements, and Design sections, demonstrating robust software engineering practices and secure data handling. 
• Lessons learned include the importance of robust deployment pipelines, granular security checks, and regular integration testing to maintain system integrity. 

In summary, the development process integrated research, design decisions, and iterative improvements to deliver a functional, secure, and scalable JavaScript-based banking system. 

 

 

docker 

Testing (Approx. 950 Words): 

Unauthorised access 

 xss 

Sql injection 

Replay attacks 

Mitm attack 

Brute force login 

Talk about rate limit 

Not telling the user if their email password reset what definitely sent 

Conclusions (Approx. 500 Words): 

Your text here.  
 

Recommendations for Further Work (Approx. 500 Words): 

Your text here.  

 

 

 

Software Artefact Download 

The complete source code for the Bank account system can be found on GitHub. To download and access the project with Visual Studio: 

Clone the repository: 

 https://github.com/LukasOgunfeitimi/WeatherAppCW1.git 

Build the project 

Build -> Build the solution 

Run the Server and Client(s) applications 

Right click the solution -> Open folder in File Explorer -> x64 -> Release -> Run the server first followed by as many client(s) you want. 

 

 

 

Glossary (Unlimited Words): 

Your text here.  

 

References (Unlimited Words): 

Literature Survey references: 

 

Diffie-Hellman Key Exchange: https://www.techtarget.com/searchsecurity/definition/Diffie-Hellman-key-exchange 

ReactJS: https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/React_getting_started 

Public key cryptography: https://www.cloudflare.com/en-gb/learning/ssl/how-does-public-key-encryption-work/ 

TLS: https://www.ncsc.gov.uk/guidance/using-tls-to-protect-data 

Wireshark: https://www.wireshark.org/ 

AES (encryption / decryption for communication between server and client: https://www.techtarget.com/searchsecurity/definition/Advanced-Encryption-Standard 

Bcrypt (password hashing): https://www.topcoder.com/thrive/articles/bcrypt-algorithm 

SHA256: https://www.n-able.com/it/blog/sha-256-encryption 

Hash-table: https://en.wikipedia.org/wiki/Hash_table 

Agile: https://asana.com/resources/agile-methodology 

Agile Scrum: https://www.cprime.com/resources/what-is-agile-what-is-scrum/  

Tailwind css: https://tailwindcss.com/ 

React router: https://reactrouter.com/ 

Node.js: https://www.w3schools.com/nodejs/nodejs_intro.asp 

Express js: https://expressjs.com/ 

JWT: https://auth0.com/docs/secure/tokens/json-web-tokens 

Supabase: https://supabase.com/ 

XSS: https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/XSS 

CSRF: https://portswigger.net/web-security/csrf#:~:text=Cross%2Dsite%20request%20forgery%20(also,do%20not%20intend%20to%20perform. 

Bcrypt: https://bcrypt-generator.com/ 

Bruteforce attack: https://www.fortinet.com/uk/resources/cyberglossary/brute-force-attack 

PM2: https://pm2.keymetrics.io/ 

https://cloud.google.com/?hl=en 

https://www.ionos.co.uk/ 

https://blog.postman.com/rest-api-examples/ 

https://safety.google/intl/en_uk/chrome/ 

https://www.digicert.com/blog/what-is-a-certificate-authority 

 

https://cryptobook.nakov.com/secure-random-generators/secure-random-generators-csprng 

 

Bibliography (Unlimited Words): 

Your text here.  
 

Appendix A: Project Plan (Unlimited Words):  

Your text here.  
 

Appendix B: Ethics Checklist (Unlimited Words):  

A checklist should be completed for every research project. This is used to identify whether a full application for ethics approval needs to be submitted to the University Ethics Panel or one of its sub-committees. Further guidance can be found on the Ethics Blackboard shell. 

 

1 Applicant details 

Name of Lead Researcher (applicant): 

      

 

2 Project details 

Project title:       

 

Please provide a brief description of the project: 

      

 

3 Research checklist  

Please answer each question by checking the appropriate box: 

Research that may need to be reviewed by an NHS Research Ethics Committee or another external Ethics Committee 

YES 

NO 

1 

Will the study involve recruitment of patients or staff through the NHS or Social Care, or the use of NHS data or premises and/or equipment?  

 

 

2 

Does the study involve participants age 16 or over who are unable to give informed consent (e.g. people with learning disabilities: see Mental Capacity Act 2005)? NHS  

 

 

3 

Will tissue samples (including blood) be obtained from participants? 

 

 

If you have answered ‘Yes’ to questions 1, 2 or 3 please refer to http://www.hra.nhs.uk/ for guidance. If external ethical approval is not needed, University ethical approval will still be required.  

Research participants 

YES 

NO 

4 

Does the study involve students within the University? 

 

 

5 

Does the study involve employees of the University? 

 

 

6 

Does the research involve potentially vulnerable groups: children, those with cognitive impairment, or those in unequal relationships? (eg your own students) 

 

 

7 

Does the research involve members of the public or people worked with in a professional capacity? 

 

 

8 

Will the study require the co-operation of a ‘gatekeeper’ for initial access to the groups or individuals to be recruited and/or to give permission for initial contact? (e.g. children, students, members of self-help group, residents of nursing home, employees). 

 

 

 

Research methods 

YES 

NO 

9 

Will it be necessary for participants to take part in the study without their knowledge and consent at the time? (e.g. covert observation of people in non-public places) 

 

 

10 

Will financial inducements (other than reasonable expenses and compensation for time) be offered to participants? 

 

 

11 

Will the study involve discussion of sensitive topics or illegal activity (e.g. sexual activity, drug use)? 

 

 

12 

Are drugs, placebos or other substances (e.g. food substances, vitamins) to be administered to the study participants or will the study involve invasive, intrusive or potentially harmful procedures of any kind? 

 

 

13 

Is physical pain or more than mild discomfort likely to result from the study? 

 

 

14 

Could the study induce psychological stress or anxiety or cause harm or negative consequences beyond the risks encountered in normal life? 

 

 

15 

Will the study involve prolonged or repetitive testing? 

 

 

16 

Is there a possibility that the safety of the researcher may be in question? 

 

 

17 

Will any of the research take place outside the UK (excluding on-line surveys)? 

 

 

 

Data and confidentiality 

 

 

18 

Will the research involve administrative or secure data that requires permission from the appropriate authorities before use? 

 

 

19 

Will the research involve visual/vocal methods where respondents may be identified? 

 

 

20 

Will research involve the sharing of data or confidential information beyond the initial consent given? 

 

 

21 

Will the research involve security-sensitive data? (eg commissioned by the military or under an EU security call; involve the acquisition of security clearances; concerns terrorist or extremist groups). 

 

 

 

If any item is checked “YES” you will need to seek advice from your supervisor / course leader regarding the appropriate sub-committee for ethical approval. 

 

 

4. Declarations 

 

I have read and will abide by the University’s Ethics Policy.  

I have read and will abide by the University’s Code Research Practice. 

I am aware of, and will abide by the ethical guidelines published by the relevant subject and/or professional associations most appropriate to my topic. 

The responses given above are an accurate and true reflection of the nature of my research project. 

 

Applicant: 

Name (please print):       

Signed: 

Date: 

Project supervisor / Line manager 

I confirm that the above details are accurate, the proposed methods are appropriate, ethical concerns have been considered and that time and resources are available for the research to take place. 

Name (please print):       

Signed: 

Date: 

 

Note: Electronic approval by above signatories is acceptable 

 

 

Appendix C: Participant Consent Form (Unlimited Words):  

Picture 10, Picture 

Text Box 7, Textbox 

Informed Consent for [name of study] 

  

Please tick the appropriate boxes 

 

 

Taking part in the study 

 

I have read and understood the study information dated [DD/MM/YYYY], or it has been read to me. I have been able to ask questions about the study and my questions have been answered to my satisfaction. 

  

o 

I consent voluntarily to be a participant in this study and understand that I can refuse to answer questions and I can withdraw from the study at any time, without having to give a reason. I can withdraw my data up until [DD/MM/YYYY] which is the final date before data is analysed. 

o 

 

I understand that taking part in the study involves […………………………………………]. 

Rectangle 6, Textbox 

 

 

 

 

 

 

 

 

If there is a potential risk of participating in the study, then provide an additional statement:  

I understand that taking part in the study has [……………………………….] as potential risk. 

 

o 

 

 

 

 

 

 

 

 

 

 

o 

 

 

COVID-19 safety 

 

I confirm that I have not had any of the following symptoms in the last 14 days: fever, dry, persistent cough or a loss of sense of taste or smell. 

o 

 

I confirm that I am not in the clinically extremely vulnerable category and therefore advised to shield at home by the government.  

o 

 

I confirm that to the best of my knowledge, I have not been in close contact with anyone with confirmed COVID-19 in the last 14 days. 

o 

 

I confirm I am aware of the requirement for social distancing whenever possible, hand decontamination, and use of face-covering during the research and that the researcher may also use further PPE. 

o 

 

I confirm I have been told about the cleaning of the venue and equipment before/after my attendance. 

o 

 

It has been confirmed by the researcher that they have not shown any of the above-named symptoms of COVID-19 nor, to the best of their knowledge, been in close contact with anyone with confirmed COVID-19 in the last 14 days. 

o 

 

 

Use of the information in the study 

 

 

I understand that information I provide will be used for [………………………………….……]. 

Rectangle 5, Textbox 

 

 

o 

 

 

I understand that personal information collected about me that can identify me, such as my name or where I live, will not be shared beyond the study team.  

 

Rectangle 4, Textbox 

 

 

 

 

o 

 

 

I consent to the processing of my personal information for the purposes of this research study. I understand that such information will be treated as strictly confidential and handled in accordance with current UK Data Protection legislation. 

 

o 

 

If you want to use quotes in research outputs, add: I agree that my information can be quoted in research outputs. 

 

o 

 

If you want to use named quotes, add: I agree that my real name can be used for quotes. 

 

o 

If written information is provided by the participant (e.g. diary), add: I agree to joint copyright of the [specify the data] to [name of researcher]. 

o 

 

Future use and reuse of the information by others 

 

I give permission for the [specify the data] that I provide to be used for future research and learning. 

Text Box 2, Textbox 

 

 

 

o 

 

 

 

 

 

 

 

 

 

Signatures 

 

 

 

_________________                              ____________________	               ___________ 

Name of participant [IN CAPITALS]	     Signature                                Date 

 

Rectangle 8, Shape 

For participants unable to sign their name, mark the box instead of signing 

 

I have witnessed the accurate reading of the consent form with the potential participant and the individual has had the opportunity to ask questions. I confirm that the individual has given consent freely. 

 

 

 

___________         _________           __________________     	  _________              __ 

Name of witness [IN CAPITALS]	                  Signature                                 Date 

 

 

 

I have accurately read out the information sheet to the potential participant and, to the best of my ability, ensured that the participant understands to what they are freely consenting. 

 

__________________                        ________________      _	   ______               __   Name of researcher [IN CAPITALS]	     Signature                                  Date 

 

 

 

Study contact details for further information  

[Name, phone number, email address] 

 

 

 

 

One copy to be kept by the participant, one to be kept by the researcher 

 

 

Other Appendixes (D, E, F etc. as required) (Unlimited Words): 

 